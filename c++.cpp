метод - функция, которая находится внутри класса
инициализация вектора
доступ к классу через двоеточие
явное объявление функции


 int a {10};
    int *pa {&a};
    std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
    int b {(*pa)++};      // инкремент значения по адресу указателя
      makes ub when you write like this : *pa++(разыменование после прибавления)     

    ///
 
    const int a {10};
    const int *pa {&a}; тут нельзя изменить переменную а ни через указатель, ни через саму переменную

   ///
int a {10};
    const int *pa {&a}; // а тут уже можно изменить переменную а, но через указатель по-прежнему нельзя ее менять 

   ///

const int a {10};
const int *pa {&a};     // указатель указывает на константу a
const int b {45};
pa = &b;  тут можно поменять на что указывает указатель pa, но нельзя поменять переменную на которую он указывает

  ///

  nt *const pa {&a}; - тут можно изменить значение переменной а через указатель, но нельзя изменить адрес переменной а

///
  
  int nums[] {1, 2, 3, 4, 5};
nums++;         // так сделать нельзя
int b {8};
nums = &b;          // так тоже сделать нельзя

///

при указателе char* ао будет выводиться строка ао, если же нкжно вывести указатель на начало массива, то его нужно привести к типу void*

        ///
char langs[][20] { "C++", "Python", "JavaScript"}; при таком объявлении у нас каждая строка будет занимать до 20 байт, в то время как С++
имеет всего 4 символа (включая нулевой в конце), так что определять лучше так, чтобы не аллоцировать лишнее место char* langs[]

  ///

  при вызове функции можно указать аргументы по умолчанию, если не будет принято это значение, то значение по умолчанию будет равно ранее указанному
///
  
void increment(int *x) тут если изменять сам х, то будет это видно в мейне, а если изменить указатель, то он в мейне останется тем же
То есть передается копия указателя(ссылка на указатель будет другой, но объект тот же)
ссылка не может ссылаться на ничего, обязательно должен быть объект, на который она ссылается, в то же время - указатель может иметь значение nullptr
так что указатель надо обязательно проверять, не ноль ли он

/// 
void print(int (*numbers)[3]);   - двумерный массив
  void print(int *numbers[3])   - массив указателей, причем обязательно при передаче либо первого, либо второго - второй параметр размера должен быть определен

  ///

  перегрузка - одинаковое название функций, но разное количество параметров или разный тип
  при перегрузке функций передача константного параметра отличается только по ссылке или указателю

////

